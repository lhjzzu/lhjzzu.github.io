<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css"/>




  <link href="//fonts.useso.com/css?family=Lato:300,400,700,400italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">



<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=0.5.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="java,同步，并发" />





  <link rel="alternate" href="/atom.xml" title="Lippi-浮生志" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=0.5.0" />






<meta name="description" content="在编程的时候经常会用到容器，当容器被多线程读取的时候我们就要考虑线程安全的问题，哪些容器是线程是线程安全的，容器的哪些操作又是线程安全的，这些安全机制是怎么实现的，本文将一一介绍。">
<meta property="og:type" content="article">
<meta property="og:title" content="java同步容器与并发容器">
<meta property="og:url" content="http://www.ezlippi.com/blog/2014/11/java-concurrent-collections.html">
<meta property="og:site_name" content="Lippi-浮生志">
<meta property="og:description" content="在编程的时候经常会用到容器，当容器被多线程读取的时候我们就要考虑线程安全的问题，哪些容器是线程是线程安全的，容器的哪些操作又是线程安全的，这些安全机制是怎么实现的，本文将一一介绍。">
<meta property="og:updated_time" content="2016-03-21T11:58:24.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java同步容器与并发容器">
<meta name="twitter:description" content="在编程的时候经常会用到容器，当容器被多线程读取的时候我们就要考虑线程安全的问题，哪些容器是线程是线程安全的，容器的哪些操作又是线程安全的，这些安全机制是怎么实现的，本文将一一介绍。">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: '博主'
    }
  };
</script>

  <title> java同步容器与并发容器 | Lippi-浮生志 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "//hm.baidu.com/hm.js?340874ba9357cbe81570aa4ac1185941";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>






  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner">
<script>
(function(){
    var bp = document.createElement('script');
    bp.src = '//push.zhanzhang.baidu.com/push.js';
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
            
<div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">Lippi-浮生志</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-home fa-fw"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-th fa-fw"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-archive fa-fw"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-tags fa-fw"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-user fa-fw"></i> <br />
            
            关于
          </a>
        </li>
      

      
      
      
    </ul>
  

  
    <div class="site-search">
      
  <form class="site-search-form">
  <input type="text" id="st-search-input" class="st-search-input st-default-search-input" />
</form>

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'fLM9qfxyerC6njvM7usy','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                java同步容器与并发容器
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">发表于</span>
            <time itemprop="dateCreated" datetime="2014-11-08T00:00:00+08:00" content="2014-11-08">
              2014-11-08
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/blog/2014/11/java-concurrent-collections.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="/blog/2014/11/java-concurrent-collections.html" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          
	
	<span id="busuanzi_container_page_pv" class="post-meta-item-text">
		&nbsp; | &nbsp;  
	    <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Hits
	</span>
        </div>
      </header>
    
	


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>在编程的时候经常会用到容器，当容器被多线程读取的时候我们就要考虑线程安全的问题，哪些容器是线程是线程安全的，容器的哪些操作又是线程安全的，这些安全机制是怎么实现的，本文将一一介绍。<br><a id="more"></a></p>
<h2 id="同步容器"><a href="#同步容器" class="headerlink" title="同步容器"></a>同步容器</h2><h3 id="1-vector和hashtable"><a href="#1-vector和hashtable" class="headerlink" title="1. vector和hashtable"></a>1. vector和hashtable</h3><p>jdk很早的时候就支持vector和hashtable，vector内部是一个数组，它的同步是在所有对元素的存取操作上进行synchronized的，也就是说每个时刻只能由一个线程可以访问容器的元素，这种线程安全是比较粗粒度的。<br>比如你在进行vector容器的迭代操作(iterator.next())时再调用vector.put(object o)时会抛出ConcurrentModificationException</p>
<hr>
<p>hashtable的内部实现：<br>  首先回顾下hashmap的实现，我们初始化一个hashmap时有两个参数inital capacity用来定义hashmap的初始化buckets数，reload factor加载因子，初始值为0.75，当hashmap中entry的数量超过这个比值时hashmap就会进行扩容，然后所有的entry进行rehash，这两个初始参数都必须选择合适的值，如果inital capacity选择太小，由于容器是开链的，会给查找元素增加额外的负担，reload factor不能选的过大，否则插入元素时出现碰撞的几率会增大。<br>hashtable就是在hashmap的基础上对所有元素的访问和插入操作用synchronized关键字同步，同样，在对容器元素迭代访问时进行插入操作会抛出ConcurrentModificationException。</p>
<hr>
<h3 id="2-collections-synchronizedXXX工厂方法创建"><a href="#2-collections-synchronizedXXX工厂方法创建" class="headerlink" title="2. collections.synchronizedXXX工厂方法创建"></a>2. collections.synchronizedXXX工厂方法创建</h3><p>  collections.synchronizedXXX是在jdk2引入的，和vector,hashtable一样，都是在整个容器上进行同步操作。<br>举个例子，下面这个是jdk7种collections.synchronizedMap的实现，这里只列出部分代码：</p>
<pre><code>private static class SynchronizedMap&lt;K,V&gt;
    implements Map&lt;K,V&gt;, Serializable {
    private static final long serialVersionUID = 1978198479659022715L;

    private final Map&lt;K,V&gt; m;     // Backing Map
    final Object      mutex;        // Object on which to synchronize

    SynchronizedMap(Map&lt;K,V&gt; m) {
        this.m = Objects.requireNonNull(m);
        mutex = this;
    }

    SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) {
        this.m = m;
        this.mutex = mutex;
    }
    //所有的操作都是在同一个监视器上进行同步
    public int size() {
        synchronized (mutex) {return m.size();}
    }
    public boolean isEmpty() {
        synchronized (mutex) {return m.isEmpty();}
    }
    public boolean containsKey(Object key) {
        synchronized (mutex) {return m.containsKey(key);}
    }
    public boolean containsValue(Object value) {
        synchronized (mutex) {return m.containsValue(value);}
    }
    public V get(Object key) {
        synchronized (mutex) {return m.get(key);}
    }

    public V put(K key, V value) {
        synchronized (mutex) {return m.put(key, value);}
    }
    public V remove(Object key) {
        synchronized (mutex) {return m.remove(key);}
    }
    public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
        synchronized (mutex) {m.putAll(map);}
    }
    public void clear() {
        synchronized (mutex) {m.clear();}
    }
</code></pre><h2 id="并发容器"><a href="#并发容器" class="headerlink" title="并发容器"></a>并发容器</h2><p>JDK5中添加了新的concurrent包，其中包含了很多并发容器，这些容器针对多线程环境进行了优化，大大提高了容器类在并发环境下的执行效率。<br>下面所有的代码都是来源于jdk7。</p>
<h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>CopyOnWriteArrayList类是一个线程安全的List接口的实现，在该类的内部进行元素的<strong>写操作时，底层的数组将被完整的复制</strong>，这对于读操作远远多于写操作的应用非常适合。在CopyOnWriteArrayList上进行操作时，<strong>读操作不需要加锁，而写操作类实现中对其进行了加锁</strong>。</p>
<p>底层实现如下：</p>
<pre><code>public class CopyOnWriteArrayList&lt;E&gt;  
    implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable {  

/** The lock protecting all mutators */
final transient ReentrantLock lock = new ReentrantLock();

/** The array, accessed only via getArray/setArray. */
private transient volatile Object[] array;
 final Object[] getArray() {
    return array;
}

  ...  
}  
</code></pre><p>读写操作：</p>
<pre><code> @SuppressWarnings(&quot;unchecked&quot;)
private E get(Object[] a, int index) {
    return (E) a[index];
}

public E get(int index) {
    return get(getArray(), index);
}
//使用ReentrantLock加锁保护
 public E set(int index, E element) {
    final ReentrantLock lock = this.lock;
    lock.lock();
    try {
        Object[] elements = getArray();
        E oldValue = get(elements, index);

        if (oldValue != element) {
            int len = elements.length;
//创建一个新的数组，复制原来的元素
            Object[] newElements = Arrays.copyOf(elements, len);
//set的元素
            newElements[index] = element;
            setArray(newElements);
        } else {
// 替换底层的数组
            setArray(elements);
        }
        return oldValue;
    } finally {
        lock.unlock();
    }
}
</code></pre><p> 特别注意：在CopyOnWriteArrayList上获得的Iterator是不能进行set和remove操作的，否则会抛出ConcurrentModificationException。</p>
<hr>
<h2 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h2><p>BlockingQueue接口定义了一种阻塞的FIFO queue，基于生产者消费者模式，每一个BlockingQueue都有一个容量，让容量满时往BlockingQueue中添加数据时会造成阻塞，当容量为空时取元素操作会阻塞。</p>
<p>ArrayBlockingQueue是对BlockingQueue的一个数组实现，它使用一把全局的锁并行对queue的读写操作，同时使用两个Condition阻塞容量为空时的取操作和容量满时的写操作。<br>底层实现：</p>
<pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

// 使用循环数组来实现queue，初始时takeIndex和putIndex均为0  
private final E[] items;  
private transient int takeIndex;  
private transient int putIndex;  
private int count;  

// 用于并发的锁和条件  
private final ReentrantLock lock;  
private final Condition notEmpty;  
private final Condition notFull;  

/** 
 * 循环数组 
 * Circularly increment i. 
 */  
final int inc(int i) {  
    return (++i == items.length)? 0 : i;  
}  

public ArrayBlockingQueue(int capacity, boolean fair) {  
    if (capacity &lt;= 0)  
        throw new IllegalArgumentException();  
    this.items = (E[]) new Object[capacity];  
    // 分配锁及该锁上的condition  
    lock = new ReentrantLock(fair);  
    notEmpty = lock.newCondition();  
    notFull =  lock.newCondition();  
}  

  ...  
}  
</code></pre><p> ArrayBlockingQueue的取操作：</p>
<pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

private E extract() {  
    final E[] items = this.items;  
    E x = items[takeIndex];  
    items[takeIndex] = null;  
    takeIndex = inc(takeIndex);  
    --count;  
   // 激发notFull条件  
    notFull.signal();  
    return x;  
}  

 /** 
 * condition的await的语义如下： 
 *　与condition相关的锁以原子方式释放，并禁用该线程 
 *　方法返回时，线程必须获得与该condition相关的锁 
 */  
public E take() throws InterruptedException {  
    final ReentrantLock lock = this.lock;  
    lock.lockInterruptibly();  
    try {  
        try {  
              // 等待notEmpty的条件  
            while (count == 0)  
                notEmpty.await();  
        } catch (InterruptedException ie) {  
        // 唤醒其他正在等待的线程  
            notEmpty.signal(); 

            throw ie;  
        }  
        E x = extract();  
        return x;  
    } finally {  
        lock.unlock();  
    }  
}  

  ...  
}  
</code></pre><p>ArrayBlockingQueue的写操作：</p>
<pre><code>public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

private void insert(E x) {  
    items[putIndex] = x;  
    putIndex = inc(putIndex);  
    ++count;  
    notEmpty.signal();  
}  

public void put(E o) throws InterruptedException {  
    if (o == null) throw new NullPointerException();  
    final E[] items = this.items;  
    final ReentrantLock lock = this.lock;  
    lock.lockInterruptibly();  
    try {  
        try {  
              // 等待notFull条件  
       while (count == items.length)  
                notFull.await();  
        } catch (InterruptedException ie) {  
    // 唤醒其他正在等待的线程      
              notFull.signal(); 

            throw ie;  
        }  
        insert(o);  
    } finally {  
        lock.unlock();  
    }  
}  

  ...  
}  
</code></pre><p>注意：ArrayBlockingQueue<strong>在读写操作上都需要锁住整个容器</strong>，因此吞吐量与一般的实现是相似的，适合于实现“生产者消费者”模式。</p>
<h2 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h2><p>LinkedBlockingQueue是BlockingQueue的一种使用Link List的实现，它<strong>对头和尾（取和添加操作）采用两把不同的锁</strong>，相对于ArrayBlockingQueue提高了吞吐量。它也是一种阻塞型的容器，适合于实现“消费者生产者”模式。</p>
<p>  LinkedBlockingQueue底层的定义如下：</p>
<pre><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

static class Node&lt;E&gt; {  
    /** The item, volatile to ensure barrier separating write and read */  

    volatile E item;  
    Node&lt;E&gt; next;  
    Node(E x) { item = x; }  
}  

// 支持原子操作  
private final AtomicInteger count = new AtomicInteger(0);  

// 链表的头和尾  
private transient Node&lt;E&gt; head;  
private transient Node&lt;E&gt; last;  

// 针对取和添加操作的两把锁及其上的条件  
private final ReentrantLock takeLock = new ReentrantLock();  
private final Condition notEmpty = takeLock.newCondition();  

private final ReentrantLock putLock = new ReentrantLock();  
private final Condition notFull = putLock.newCondition();  

   ...  
} 
</code></pre><p>  LinkedBlockingQueue的添加操作：</p>
<pre><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

private void insert(E x) {  
    last = last.next = new Node&lt;E&gt;(x);  
}  

/** 
 * signal方法在被调用时，当前线程必须拥有该condition相关的锁! 
 * Signal a waiting take. Called only from put/offer (which do not otherwise ordinarily lock takeLock.) 
 */  
private void signalNotEmpty() {  
    final ReentrantLock takeLock = this.takeLock;  
    takeLock.lock();  
    try {  
        notEmpty.signal();  
    } finally {  
        takeLock.unlock();  
    }  
}  

public void put(E o) throws InterruptedException {  
    if (o == null) throw new NullPointerException();  
    int c = -1;  
    final ReentrantLock putLock = this.putLock;  
    final AtomicInteger count = this.count;  
    // 使用putLock  
    putLock.lockInterruptibly();  
    try {  
        try {  
              // 当容量已满时，等待notFull条件  
        while (count.get() == capacity)  
                notFull.await();  
        } catch (InterruptedException ie) {  
            notFull.signal(); // propagate to a non-interrupted thread  
            throw ie;  
        }  
        insert(o);  
        // 取出当前值，并将原数据增加1  
        c = count.getAndIncrement();  
        // 容量不满，再次激活notFull上等待的put线程  
    if (c + 1 &lt; capacity)  
            notFull.signal();  
    } finally {  
        putLock.unlock();  
    }  
    // 必须先释放putLock再在notEmpty上signal，否则会造成死锁  
 if (c == 0)  
        signalNotEmpty();  
}  

  ...  
}   
</code></pre><p> LinkedBlockingQueue的取操作：</p>
<pre><code>public class LinkedBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements BlockingQueue&lt;E&gt;, java.io.Serializable {  

private E extract() {  
    Node&lt;E&gt; first = head.next;  
    head = first;  
    E x = first.item;  
    first.item = null;  
    return x;  
}  

private void signalNotFull() {  
    final ReentrantLock putLock = this.putLock;  
    putLock.lock();  
    try {  
        notFull.signal();  
    } finally {  
        putLock.unlock();  
    }  
}  

public E take() throws InterruptedException {  
    E x;  
    int c = -1;  
    final AtomicInteger count = this.count;  
    final ReentrantLock takeLock = this.takeLock;  
    // 使用takeLock  
    takeLock.lockInterruptibly();  
    try {  
        try {  
              // 若容量为空，等待notEmpty  
            while (count.get() == 0)  
                notEmpty.await();  
        } catch (InterruptedException ie) {  
            notEmpty.signal(); // propagate to a non-interrupted thread  
            throw ie;  
        }  

        x = extract();  
        c = count.getAndDecrement();  
        // 再次激活notEmpty  
        if (c &gt; 1)  
            notEmpty.signal();  
    } finally {  
        takeLock.unlock();  
    }  
    // take执行之前容量已满，则激活notFull  
    if (c == capacity)  
        signalNotFull();  
    return x;  
}  

  ...  
}  
</code></pre><hr>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p> ConcurrentHashMap是Map的一种并发实现，在该类中<strong>元素的read操作都是无锁了，而write操作需要被同步</strong>。这非常适合于读操作远大于写操作的情况。在实现过程中，ConcurrentHashMap将所有元素分成了若干个segment，每个segment是独立的，在一个segment上加锁并不影响其他segment的操作。segment本身是一个hashtable，对于一个加入ConcurrentHashMap的<key, value="">对，key的hash值中的高位被用来索引segment，而低位用于segment中的索引。</key,></p>
<p>虽然读操作不阻塞，但是读到的值可能不是最新的值，因为可能有其他线程又更新了元素，Iterator操作也是一样，包括size(),isEmpty(),containValue()返回的结果可能是错误的，而且每个时刻只有一个线程可以访问迭代器。</p>
<p>  segment是ConcurrentHashMap存储元素的基本段，它本身是一个hashtable的实现，read操作时无锁的，write需要同步，定义如下：</p>
<pre><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  


/** 
 *  key, hash, next都是不可改的 
*  value值可被重写 
*/  
static final class HashEntry&lt;K,V&gt; {  
    final K key;  
    final int hash;  
    volatile V value;  
    final HashEntry&lt;K,V&gt; next;  

    ...  
 }  

   static final class Segment&lt;K,V&gt; extends ReentrantLock   implements Serializable {  

    transient volatile int count;  
    transient volatile HashEntry[] table;  
    // 当segment中元素个数达到threshold时，需要rehash  
    transient int threshold;  
}  

  ...  
}
</code></pre><p> segment的read操作：</p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  

  HashEntry&lt;K,V&gt; getFirst(int hash) {  
      HashEntry[] tab = table;  
      return (HashEntry&lt;K,V&gt;) tab[hash &amp; (tab.length - 1)];  
  }  

 V get(Object key, int hash) { // 该操作是无锁的  
      if (count != 0) { // read-volatile  
          HashEntry&lt;K,V&gt; e = getFirst(hash);  
          while (e != null) {  
              if (e.hash == hash &amp;&amp; key.equals(e.key)) {  
                  V v = e.value;  
                  if (v != null)  
                      return v;  
                    // recheck  
                  return readValueUnderLock(e);

              }  
              e = e.next;  
          }  
      }  
      return null;  
  }  

...  
} 
</code></pre><p>  由于HashEntry当中的key和next都是final的，所以segment之上的操作不可能影响HashEntry列表之间相对的顺序，而value是可变的，当第一次读值失败时，尝试加锁读。<br>  segment的replace操作：  </p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  

   /** 
   * replace操作是就地替换，HashEntry的value是非final的 
   */  
    boolean replace(K key, int hash, V oldValue, V newValue) {  
        lock();  // replace操作是同步的  
    try {  
            // 得到该hash值对应的entry列表  
       HashEntry&lt;K,V&gt; e = getFirst(hash);  
       while (e != null &amp;&amp; (e.hash != hash || !                key.equals(e.key)))  
             e = e.next;  

            boolean replaced = false;  
            if (e != null &amp;&amp; oldValue.equals(e.value)) {     // 替换  
                  replaced = true;  
                 e.value = newValue;  
            }  
            return replaced;  
        } finally {  
            unlock();  
        }  
    }  

  ...  
}  
</code></pre><p>segment的remove操作一种copy on write 的方法，保留被删元素之后的列表，copy被删元素之前的hashEntry：</p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  

    V remove(Object key, int hash, Object value) {  
        lock();  
        try {  
            int c = count - 1;  
            HashEntry[] tab = table;  
            int index = hash &amp; (tab.length - 1);  
            HashEntry&lt;K,V&gt; first = (HashEntry&lt;K,V&gt;)tab[index];  
            HashEntry&lt;K,V&gt; e = first;  
            while (e != null &amp;&amp; (e.hash != hash || !key.equals(e.key)))  
                e = e.next;  

            V oldValue = null;  
            if (e != null) {  
                V v = e.value;  
                if (value == null || value.equals(v)) { // copy on write  
                    oldValue = v;  
                    ++modCount;  
                    // e之后的列表可以保留，只需要重新创建e之前的HashEntry即可  
             HashEntry&lt;K,V&gt; newFirst = e.next;  
                    // copy on write e之前的HashEntry  
                    for (HashEntry&lt;K,V&gt; p = first; p != e; p = p.next)  
                        newFirst = new HashEntry&lt;K,V&gt;(p.key, p.hash,    
                                                      newFirst, p.value);  
                    tab[index] = newFirst;  
                    count = c; // write-volatile  
                }  
            }  
            return oldValue;  
        } finally {  
            unlock();  
        }  
    }  

  ...  
}  
</code></pre><p>segment的rehash操作实现比较特别，为了保证rehash过程中copy的元素尽可能少，segment在rehash时Entry入口的个数是以2的倍数增长，这可以保证一个entry在rehash之后要么在原来的列表中，要么在下一个列表中：</p>
<pre><code>static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable {  

    void rehash() {  
        // 局部变量引用table  
        HashEntry[] oldTable = table;              
        int oldCapacity = oldTable.length;  
        if (oldCapacity &gt;= MAXIMUM_CAPACITY)  
            return;  

        // 右移1位相当于乘以2  
        HashEntry[] newTable = new HashEntry[oldCapacity &lt;&lt; 1];  
        threshold = (int)(newTable.length * loadFactor);  
        int sizeMask = newTable.length - 1;  
        for (int i = 0; i &lt; oldCapacity ; i++) {  
            // 第i个entry列表  
       HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;)oldTable[i];  

            if (e != null) {  
                HashEntry&lt;K,V&gt; next = e.next;  
                // 在新table上的索引  
                int idx = e.hash &amp; sizeMask;  

                if (next == null)  
                    newTable[idx] = e;  
                else {  
                    // 寻找该entry列表末端，rehash之后idx相同的元素  
                    // 这些元素不需要被copy  
                    HashEntry&lt;K,V&gt; lastRun = e;  
                    int lastIdx = idx;  
                    for (HashEntry&lt;K,V&gt; last = next;  
                         last != null;  
                         last = last.next) {  
                        int k = last.hash &amp; sizeMask;  
                        if (k != lastIdx) {  
                            lastIdx = k;  
                            lastRun = last;  
                        }  
                    }  
                    // 将lastRun之后的整个列表挂到新位置上  
                    newTable[lastIdx] = lastRun;  

                    // Clone all remaining nodes  
                    for (HashEntry&lt;K,V&gt; p = e; p != lastRun; p = p.next) {  
                        int k = p.hash &amp; sizeMask;  
                        HashEntry&lt;K,V&gt; n = (HashEntry&lt;K,V&gt;)newTable[k];  
                        newTable[k] = new HashEntry&lt;K,V&gt;(p.key, p.hash,  
                                                         n, p.value);  
                    }  
                }  
            }  
        }  
        table = newTable;  
    }  

  ...  
}
</code></pre><p> ConcurrentHashMap在Segment的基础上，通过首先将<key, value="">对hash到一个segment，再由segment实现对entry的管理。</key,></p>
<p>ConcurrentHashMap的get实现：</p>
<pre><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  

final Segment&lt;K,V&gt; segmentFor(int hash) {  
    return (Segment&lt;K,V&gt;) segments[(hash &gt;&gt;&gt; segmentShift) &amp; segmentMask];  
}  

public V get(Object key) {  
    int hash = hash(key); // throws NullPointerException if key null  
    return segmentFor(hash).get(key, hash);  
}  

  ...  
}  
</code></pre><p>ConcurrentHashMap的put和get方法：</p>
<pre><code>public class ConcurrentHashMap&lt;K, V&gt; extends AbstractMap&lt;K, V&gt;  
    implements ConcurrentMap&lt;K, V&gt;, Serializable {  

public V put(K key, V value) {  
    if (value == null)  
        throw new NullPointerException();  
    int hash = hash(key);  
    return segmentFor(hash).put(key, hash, value, false);  
}  

public V remove(Object key) {  
    int hash = hash(key);  
    return segmentFor(hash).remove(key, hash, null);  
}  
</code></pre><p>  …<br>}</p>
<hr>
<h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue充分使用了atomic包的实现<strong>打造了一个无锁并发线程安全的队列</strong>。对比锁机制的实现，个人认为使用无锁机制的难点在于要充分考虑线程间的协调。简单的说就是多个线程对内部数据结构进行访问时，如果其中一个线程执行的中途因为一些原因出现故障，其他的线程能够检测并帮助完成剩下的操作。这就需要把对数据结构的操作过程精细的划分成多个状态或阶段，考虑每个阶段或状态多线程访问会出现的情况。上述的难点在此次分析的并发Queue的实现中有很好的说明。</p>
<p>对于多线程同时访问容器元素的情况，concurrentLinkedQueue是一个很好的选择，因为所有的操作都是非阻塞的，所以它的迭代操作返回的结果并不是最新的，不会出现concurrentmodificationException。</p>
<p>而且不像很多其他容器，ConcurrentLinkedQueue的size()操作不是常量时间，返回的结果也不一定是准确的。</p>
<pre><code>public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt;  
    implements Queue&lt;E&gt;, java.io.Serializable {  
private static final long serialVersionUID = 196745693267521676L;  

private static class Node&lt;E&gt; {  
    private volatile E item;  
    private volatile Node&lt;E&gt; next;  

    private static final  
        AtomicReferenceFieldUpdater&lt;Node, Node&gt;  
        nextUpdater =  
        AtomicReferenceFieldUpdater.newUpdater  
        (Node.class, Node.class, &quot;next&quot;);  
    private static final  
        AtomicReferenceFieldUpdater&lt;Node, Object&gt;  
        itemUpdater =  
        AtomicReferenceFieldUpdater.newUpdater  
        (Node.class, Object.class, &quot;item&quot;);  

    Node(E x) { item = x; }  

    Node(E x, Node&lt;E&gt; n) { item = x; next = n; }  

    E getItem() {  
        return item;  
    }  

    boolean casItem(E cmp, E val) {  
        return itemUpdater.compareAndSet(this, cmp, val);  
    }  

    void setItem(E val) {  
        itemUpdater.set(this, val);  
    }  

    Node&lt;E&gt; getNext() {  
        return next;  
    }  

    boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
        return nextUpdater.compareAndSet(this, cmp, val);  
    }  

    void setNext(Node&lt;E&gt; val) {  
        nextUpdater.set(this, val);  
    }  

}  

private static final  
    AtomicReferenceFieldUpdater&lt;ConcurrentLinkedQueue, Node&gt;  
    tailUpdater =  
    AtomicReferenceFieldUpdater.newUpdater  
    (ConcurrentLinkedQueue.class, Node.class, &quot;tail&quot;);  
private static final  
    AtomicReferenceFieldUpdater&lt;ConcurrentLinkedQueue, Node&gt;  
    headUpdater =  
    AtomicReferenceFieldUpdater.newUpdater  
    (ConcurrentLinkedQueue.class,  Node.class, &quot;head&quot;);  

private boolean casTail(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
    return tailUpdater.compareAndSet(this, cmp, val);  
}  

private boolean casHead(Node&lt;E&gt; cmp, Node&lt;E&gt; val) {  
    return headUpdater.compareAndSet(this, cmp, val);  
}  

private transient volatile Node&lt;E&gt; head = new Node&lt;E&gt;(null, null);  

private transient volatile Node&lt;E&gt; tail = head;  
...  
}  
</code></pre><p>先看看其内部数据结构Node的实现。由于使用了原子字段更新器<code>AtomicReferenceFieldUpdater&lt;T,V&gt;</code>（其中T表示持有字段的类的类型，V表示字段的类型），所以其对应的需要更新的字段要使用volatile进行声明。其<code>newUpdater(Class&lt;U&gt; tclass, Class&lt;W&gt; vclass, String fieldName)</code>方法实例化一个指定字段的更新器，参数分别表示：持有需要更新字段的类，字段的类，要更新的字段的名称。Node的内部变量item，next分别有对应自己的字段更新器，并且包含了对其原子性操作的方法<code>compareAndSet(T obj, V expect, V update)</code>，其中T是持有被设置字段的对象，后两者分别是期望值和新值。 </p>
<p>对于ConcurrentLinkedQueue自身也有<strong>两个volatile的线程共享变量：head，tail分别对应队列的头指针和尾指针</strong>。要保证这个队列的线程安全就是保证对这两个Node的引用的访问（更新，查看）的原子性和可见性，由于volatile本身能够保证可见性，所以就是对其修改的原子性要被保证：</p>
<pre><code>public boolean offer(E e) {  
if (e == null) throw new NullPointerException();  
Node&lt;E&gt; n = new Node&lt;E&gt;(e, null);  
for (;;) {  
    Node&lt;E&gt; t = tail;  
    Node&lt;E&gt; s = t.getNext();  
    if (t == tail) { //-----------------------------a  
        if (s == null) { //-------------------------b  
            if (t.casNext(s, n)) { //---------------c  
                casTail(t, n); //-------------------d  
                return true;  
            }  
        } else {  
            casTail(t, s); //-----------------------e  
        }  
    }  
}  
</code></pre><p>}  </p>
<p>offer()方法都很熟悉了，就是入队的操作。涉及到改变尾指针的操作，所以要看这个方法实现是否保证了原子性。CAS操作配合循环是原子性操作的保证，这里也不例外。此方法的循环内首先获得尾指针和其next指向的对象，由于tail和Node的next均是volatile的，所以保证了获得的分别都是最新的值。 </p>
<hr>
<ul>
<li><p>代码a：<code>t==tail</code>是最上层的协调，如果其他线程改变了tail的引用，则说明现在获得不是最新的尾指针需要重新循环获得最新的值。 </p>
</li>
<li><p>代码b：<code>s==null</code>的判断。静止状态下tail的next一定是指向null的，但是多线程下的另一个状态就是中间态：tail的指向没有改变，但是其next已经指向新的结点，即完成tail引用改变前的状态，这时候<code>s!=null</code>。这里就是协调的典型应用，直接进入代码e去协调参与中间态的线程去完成最后的更新，然后重新循环获得新的tail开始自己的新一次的入队尝试。另外值得注意的是a,b之间，其他的线程可能会改变tail的指向，使得协调的操作失败。从这个步骤可以看到无锁实现的复杂性。</p>
</li>
<li><p>代码c：<code>t.casNext(s, n)</code>是入队的第一步，因为入队需要两步：更新Node的next，改变tail的指向。代码c之前可能发生tail引用指向的改变或者进入更新的中间态，这两种情况均会使得t指向的元素的next属性被原子的改变，不再指向null。这时代码c操作失败，重新进入循环。</p>
</li>
<li><p>代码d：这是完成更新的最后一步了，就是更新tail的指向，最有意思的协调在这儿又有了体现。从代码看<code>casTail(t, n)</code>不管是否成功都会接着返回true标志着更新的成功。首先如果成功则表明本线程完成了两步的更新，返回true是理所当然的；如果 <code>casTail(t, n)</code>不成功呢？要清楚的是完成代码c则代表着更新进入了中间态，代码d不成功则是tail的指向被其他线程改变。意味着对于其他的线程而言：它们得到的是中间态的更新，<code>s!=null</code>，进入代码e帮助本线程执行最后一步并且先于本线程成功。这样本线程虽然代码d失败了，但是是由于别的线程的协助先完成了，所以返回true也就理所当然了。 </p>
</li>
</ul>
<hr>
<p>通过分析这个入队的操作，可以清晰的看到无锁实现的每个步骤和状态下多线程之间的协调和工作。理解了入队的整个过程，出队的操作<code>poll()</code>的实现也就变得简单了。基本上是大同小异的，无非就是同时牵涉到了head和tail的状态，在改变head的同时照顾到tail的协调，在此不多赘述。下面介绍一下其无锁下的查看访问，其内部不单单是查看更包含了线程间的协调，这是无锁实现的一个特点。不管是<code>contains()，size()</code>还是isEmpty()，只要获得了head后面第一个最新的Node就可以很轻松的实现，毕竟Node的<code>getNext()和getItem()</code>返回的都是对应的最新值。所以先看看这些方法内部的first()如何获得最新的第一个Node： </p>
<pre><code>Node&lt;E&gt; first() {  
for (;;) {  
    Node&lt;E&gt; h = head;  
    Node&lt;E&gt; t = tail;  
    Node&lt;E&gt; first = h.getNext();  
    if (h == head) { //----------------  ---------a  
        if (h == t) { //--------------------------b  
            if (first ==null) --------------------c  
                return null;  
            else  
                casTail(t, first); //-------------d  
        } else {  
            if (first.getItem() != null) //-------e  
                return first;  
            else
             // remove deleted node and continue  
                casHead(h, first); //-------------f  
        }  
    }  
}  
</code></pre><p>}  </p>
<p>此方法在尝试获得最新的第一个非head结点的时候，在不同的阶段同样在协调着head和tail的更新任务，让人感觉无锁的世界没有纯粹的工作，呵呵。 </p>
<ul>
<li><p>代码a：还是最上层的协调，head指向没改变的情况下才继续下面的操作。这时侯head只可能是静止的，因为<code>poll()</code>出队操作的步骤是反着的：首先更新head的指向进入中间态，然后更新原head的next的item为null。 </p>
</li>
<li><p>代码b：之所以<code>h==t</code>的情况独立于其他的情况(在出队<code>poll()</code>方法中同样)，主要是因为<code>first!=null</code>时可能对应着某一个更新的中间态，而产生中间态的的必要条件就是代码b成立。如果<code>h==t</code>则表示当前线程获得的首尾指针指向同一个结点，当然代码b执行之后可能其他线程会进行head或者tail的更新。</p>
</li>
<li><p>代码c：<code>first==null</code>表明tail并没有进入更新的中间态而是处于静止状态，并且由于tail指向的是head的指向，所以返回null是唯一的选择。但是这美好的一切都是建立在代码b和代码c之间没有其他的线程更新tail。一旦有其他的线程执行了入队的操作并至少进入中间态的话，<code>h==t和first==null</code>都遗憾的成立，这就造成了取得幻象值，而实际上h.getNext()已经不再为null。个人认为代码c改成<code>if((first = h.getNext()) == null)</code>更能提高命中率。 </p>
</li>
<li><p>代码d：只要`first!=null，本线程则去尝试协调其他的线程先完成tail的更新，等待循环再次获取最新的head和tail。 </p>
</li>
<li><p>代码e：此处first一定不为null，tail更新与否不影响first的item的获取，但是head的更新会有影响。如果head正在被另一个线程更新并进入中间态，既是poll()内的<code>else if (casHead(h, first))</code> 成功，但是并没有执行first.setItem(null)之前。此时代码e是满足的，返回的也是当前的first的，但是随后head全部更新成功则first的item为null。所以此处返回的first的item并不一定是<code>item!=null</code>的结点，在使用此方法获得的结点的item时一定要再次的进行判断，这点在contains(…)等方法内都有体现。 </p>
</li>
<li><p>代码f：如果first的<code>item==null</code>，则更新head的指向。直观上看似乎多余，因为出队的操作是先更新head的指向再更新item为null的。但是另一个方法remove(…)则仅仅更新item的值而不改变head的指向，所以针对这样的多线程调用，代码f变得非常的必需了。 </p>
</li>
</ul>
<hr>
<p>这样通过这两个方法的分析可以推及对ConcurrentLinkedQueue共享变量的其他操作的实现，这样的无锁的实现印象最深的就是要考虑线程间的协调。不像锁机制的实现虽然牺牲了一定的性能，但是至少操作这些非线程安全的共享变量时不用过多的考虑其他线程的操作。</p>

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag">#java</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/blog/2014/11/how-to-evaluate-the-hackers-and-painters.html" rel="next" title="如何评价『黑客与画家』">
                <i class="fa fa-chevron-left"></i> 如何评价『黑客与画家』
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/blog/2014/11/java-inner-class.html" rel="prev" title="java中内部类">
                java中内部类 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
        <div class="ds-share flat" data-thread-key="/blog/2014/11/java-concurrent-collections.html"
     data-title="java同步容器与并发容器"
     data-content=""
     data-url="http://www.ezlippi.com//blog/2014/11/java-concurrent-collections.html">
  <div class="ds-share-inline">
    <ul  class="ds-share-icons-16">

      <li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
      <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
      <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
      <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
      <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>

    </ul>
    <div class="ds-share-icons-more">
    </div>
  </div>
</div>
      
    </div>
  </div>


          </div>
          

  <p>热评文章</p>
  <div class="ds-top-threads" data-range="weekly" data-num-items="4"></div>


          
  <div class="comments" id="comments">
    
      <div class="ds-thread" data-thread-key="/blog/2014/11/java-concurrent-collections.html"
           data-title="java同步容器与并发容器" data-url="http://www.ezlippi.com//blog/2014/11/java-concurrent-collections.html">
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="EZLippi" />
          <p class="site-author-name" itemprop="name">EZLippi</p>
          <p class="site-description motion-element" itemprop="description">Easy Lippi</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">63</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>
          
          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">22</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">69</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/EZLippi" target="_blank">
                  
                    <i class="fa fa-github"></i> GitHub
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/ouyanglip" target="_blank">
                  
                    <i class="fa fa-weibo"></i> weibo
                  
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/people/lippi-ouyang" target="_blank">
                  
                    <i class="fa fa-weibo"></i> zhihu
                  
                </a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">友情链接</p>
            
              <span class="links-of-author-item">
                <a href="http://szhshp.org" target="_blank">szhshp的博客</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://www.zhihu.com/people/lippi-ouyang" target="_blank">友链出租</a>
              </span>
            
          
        </div>

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc-indicator-top post-toc-indicator">
            <i class="fa fa-angle-double-up"></i>
          </div>
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#同步容器"><span class="nav-number">1.</span> <span class="nav-text">同步容器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-vector和hashtable"><span class="nav-number">1.1.</span> <span class="nav-text">1. vector和hashtable</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-collections-synchronizedXXX工厂方法创建"><span class="nav-number">1.2.</span> <span class="nav-text">2. collections.synchronizedXXX工厂方法创建</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#并发容器"><span class="nav-number">2.</span> <span class="nav-text">并发容器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CopyOnWriteArrayList"><span class="nav-number">3.</span> <span class="nav-text">CopyOnWriteArrayList</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BlockingQueue"><span class="nav-number">4.</span> <span class="nav-text">BlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#LinkedBlockingQueue"><span class="nav-number">5.</span> <span class="nav-text">LinkedBlockingQueue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentHashMap"><span class="nav-number">6.</span> <span class="nav-text">ConcurrentHashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ConcurrentLinkedQueue"><span class="nav-number">7.</span> <span class="nav-text">ConcurrentLinkedQueue</span></a></li></ol></div>
            
          </div>
          <div class="post-toc-indicator-bottom post-toc-indicator">
            <i class="fa fa-angle-double-down"></i>
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2014 - 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">EZLippi</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
   托管在 -
  <a class="theme-link" href="https://github.com/EZLippi/EZLippi.github.io">
    Github
  </a>

</div>
<div class="theme-info">
<span id="busuanzi_container_site_pv">
    &nbsp; | &nbsp;本站总访问量<span id="busuanzi_value_site_pv"></span>次
</span>
</div>
<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>



      </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  


  



  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>

  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=0.5.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=0.5.0"></script>



  
  

  
  
<script type="text/javascript" src="/js/src/scrollspy.js?v=0.5.0"></script>

<script type="text/javascript" id="sidebar.toc.highlight">
  $(document).ready(function () {
    var tocSelector = '.post-toc';
    var $tocSelector = $(tocSelector);
    var activeCurrentSelector = '.active-current';

    $tocSelector
      .on('activate.bs.scrollspy', function () {
        var $currentActiveElement = $(tocSelector + ' .active').last();

        removeCurrentActiveClass();
        $currentActiveElement.addClass('active-current');

        $tocSelector[0].scrollTop = $currentActiveElement.position().top;
      })
      .on('clear.bs.scrollspy', function () {
        removeCurrentActiveClass();
      });

    function removeCurrentActiveClass () {
      $(tocSelector + ' ' + activeCurrentSelector)
        .removeClass(activeCurrentSelector.substring(1));
    }

    function processTOC () {
      getTOCMaxHeight();
      toggleTOCOverflowIndicators();
    }

    function getTOCMaxHeight () {
      var height = $('.sidebar').height() -
                   $tocSelector.position().top -
                   $('.post-toc-indicator-bottom').height();

      $tocSelector.css('height', height);

      return height;
    }

    function toggleTOCOverflowIndicators () {
      tocOverflowIndicator(
        '.post-toc-indicator-top',
        $tocSelector.scrollTop() > 0 ? 'show' : 'hide'
      );

      tocOverflowIndicator(
        '.post-toc-indicator-bottom',
        $tocSelector.scrollTop() >= $tocSelector.find('ol').height() - $tocSelector.height() ? 'hide' : 'show'
      )
    }

    $(document).on('sidebar.motion.complete', function () {
      processTOC();
    });

    $('body').scrollspy({ target: tocSelector });
    $(window).on('resize', function () {
      if ( $('.sidebar').hasClass('sidebar-active') ) {
        processTOC();
      }
    });

    onScroll($tocSelector);

    function onScroll (element) {
      element.on('mousewheel DOMMouseScroll', function (event) {
          var oe = event.originalEvent;
          var delta = oe.wheelDelta || -oe.detail;

          this.scrollTop += ( delta < 0 ? 1 : -1 ) * 30;
          event.preventDefault();

          toggleTOCOverflowIndicators();
      });
    }

    function tocOverflowIndicator (indicator, action) {
      var $indicator = $(indicator);
      var opacity = action === 'show' ? 1 : 0;
      $indicator.velocity ?
        $indicator.velocity('stop').velocity({
          opacity: opacity
        }, { duration: 100 }) :
        $indicator.stop().animate({
          opacity: opacity
        }, 100);
    }

  });
</script>

<script type="text/javascript" id="sidebar.nav">
  $(document).ready(function () {
    var html = $('html');
    var TAB_ANIMATE_DURATION = 200;
    var hasVelocity = $.isFunction(html.velocity);

    $('.sidebar-nav li').on('click', function () {
      var item = $(this);
      var activeTabClassName = 'sidebar-nav-active';
      var activePanelClassName = 'sidebar-panel-active';
      if (item.hasClass(activeTabClassName)) {
        return;
      }

      var currentTarget = $('.' + activePanelClassName);
      var target = $('.' + item.data('target'));

      hasVelocity ?
        currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function () {
          target
            .velocity('stop')
            .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION)
            .addClass(activePanelClassName);
        }) :
        currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function () {
          currentTarget.hide();
          target
            .stop()
            .css({'opacity': 0, 'display': 'block'})
            .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function () {
              currentTarget.removeClass(activePanelClassName);
              target.addClass(activePanelClassName);
            });
        });

      item.siblings().removeClass(activeTabClassName);
      item.addClass(activeTabClassName);
    });

    $('.post-toc a').on('click', function (e) {
      e.preventDefault();
      var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href'));
      var offset = $(targetSelector).offset().top;
      hasVelocity ?
        html.velocity('stop').velocity('scroll', {
          offset: offset  + 'px',
          mobileHA: false
        }) :
        $('html, body').stop().animate({
          scrollTop: offset
        }, 500);
    });

    // Expand sidebar on post detail page by default, when post has a toc.
    NexT.motion.middleWares.sidebar = function () {
      var $tocContent = $('.post-toc-content');

      if (CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always') {
        if ($tocContent.length > 0 && $tocContent.html().trim().length > 0) {
          NexT.utils.displaySidebar();
        }
      }
    };
  });
</script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=0.5.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"ezlippi"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
  





  
  

  
  


</body>
</html>
