---
layout: post
title: WebViewJavaScriptBridge原理
date: 2016-06-28
categories: IOS

---
## 基本作用
用来进行h5与native之间进行消息传递，从而进行事件的交互。

## 基本使用

简单说来，就是在native端进行事件注册，在h5端进行调用。在h5端进行事件注册，在native端进行调用。

### 一 在h5进行事件注册,在navive进行事件的调用

在h5注册默认事件

1 在h5端注册默认的事件，并定义对来自native的消息的处理函数
function(message, responseCallback)，并在处理完成后，调用回调函数responseCallback(data)，将处理后的数据回调给native

```
bridge.init(function(message, responseCallback) {
			log('JS got a message', message)
			var data = { 'Javascript Responds':'Wee!' }
			log('JS responding with', data)
			responseCallback(data)
		})
```

2 在native调用h5注册的默认事件,将native端的消息传递给h5。同时定义responseCallback的block块，来处理h5回调给native的数据

```
[_bridge send:@"A string sent from ObjC to JS" responseCallback:^(id response) {
        NSLog(@"sendMessage got response: %@", response);
    }];
```

在h5注册一般事件


1 在h5端注册名为`testJavascriptHandler`的事件，并定义对来自native的消息的处理函数
function(message, responseCallback)，并在处理完成后，调用回调函数responseCallback(data)，将处理后的数据回调给native

```
bridge.registerHandler('testJavascriptHandler', function(data, responseCallback) {
			log('ObjC called testJavascriptHandler with', data)
			var responseData = { 'Javascript Says':'Right back atcha!' }
			log('JS responding with', responseData)
			responseCallback(responseData)
		})		
```

2 在native调用h5注册的`testJavascriptHandler`事件,将native端的消息传递给h5。同时定义responseCallback的block块，来处理h5回调给native的数据

```
 id data = @{ @"greetingFromObjC": @"Hi there, JS!" };
    [_bridge callHandler:@"testJavascriptHandler" data:data responseCallback:^(id response) {
        NSLog(@"testJavascriptHandler responded: %@", response);
    }];
```

### 二 在native进行事件注册,在h5进行事件的调用

在native注册默认事件

1 在native注册默认的事件，并定义对来自h5的消息的处理函数
handler，并在处理完成后，调用回调函数responseCallback(data)，将处理后的数据回调给h5

```

    _bridge = [WebViewJavascriptBridge bridgeForWebView:webView webViewDelegate:self handler:^(id data, WVJBResponseCallback responseCallback) {
        NSLog(@"ObjC received message from JS: %@", data);
        responseCallback(@"Response for message from ObjC");
    }];
    
```
2 在h5调用native注册的默认事件,将h5端的消息传递给native。同时定义responseCallback的block块，来处理native回调给h5的数据

```
var data = 'Hello from JS button'
bridge.send(data, function(responseData) {
				log('JS got response', responseData)
			})
```

在native注册一般事件

1 在native注册名为`testObjcCallback`的事件，并定义对来自h5的消息的处理函数
handler，并在处理完成后，调用回调函数responseCallback(data)，将处理后的数据回调给h5

```

      [_bridge registerHandler:@"testObjcCallback" handler:^(id data, WVJBResponseCallback responseCallback) {
        NSLog(@"testObjcCallback called: %@", data);
        responseCallback(@"Response from testObjcCallback");
    }];
    
```

2 在h5调用native注册的`testObjcCallback`事件,将h5端的消息传递给native。同时定义responseCallback的block块，来处理native回调给h5的数据

```
var data = 'Hello from JS button'
bridge.callHandler('testObjcCallback', {'foo': 'bar'}, function(response) {
				log('JS got response', response)
			})
```


## bridge的基本类


### `WebViewJavascriptBridgeBase`

属性

`startupMessageQueue`:在`WebViewJavascriptBridge.js.txt`文件还没有载入时，先把native发送给h5的message存储在startupMessageQueue数组中，一旦`WebViewJavascriptBridge.js.txt`载入完成就遍历处理存储的消息.

`responseCallbacks`: 把native调用h5时，定义的WVJBResponseCallback类型的block块，以`objc_cb_xx`(callbackId)为key,存储在`responseCallbacks`字典中。

`messageHandlers`:存储注册在native端的事件处理函数。以注册的事件名为key,以注册事件时定义的WVJBHandler类型的block块为value.（一般事件）

`messageHandler`: 在native注册的默认的事件的处理函数。(默认事件)

`delegate`:指遵守`WebViewJavascriptBridgeBaseDelegate`协议的类，在这里指的就是`WebViewJavascriptBridge`/`WKWebViewJavascriptBridge`,这两个类都遵守该协议，并通过该协议的`_evaluateJavascript`方法，调用js命令。

方法
`+ (void)enableLogging`:是否能够log

`-(id)initWithHandler:(WVJBHandler)messageHandler resourceBundle:(NSBundle * )bundle`:初始化方法

`-(void)reset`:重置方法

`- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString * )handlerName`:从native调用h5的方法. 

`- (void)flushMessageQueue:(NSString * )messageQueueString`:处理从h5传递过来的消息字符串

`- (void)injectJavascriptFile:(BOOL)shouldInject`:是否注册js文件

`- (BOOL)isCorrectProcotocolScheme:(NSURL * )url`:

`- (BOOL)isCorrectHost:(NSURL* )url`:域名是否正确

`- (void)logUnkownMessage:(NSURL*)url`:打印未知消息

`- (void)dispatchStartUpMessageQueue`:当js文件载入完成后，处理存储在startupMessageQueue数组中的消息.

`- (NSString *)webViewJavascriptCheckCommand`:返回js命令，该命令用于检查js文件中`WebViewJavascriptBridge`的对象是否创建好。

`- (NSString *)webViewJavascriptFetchQueyCommand`:返回js命令，该命令用于调用js中的`_fetchQueue()`函数

### `WebViewJavascriptBridge`

h5与UIWeView交互的桥梁

WebViewJavascriptBridge的初始化方法

```
+ (instancetype)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView handler:(WVJBHandler)handler
+ (instancetype)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler
+ (instancetype)bridgeForWebView:(WVJB_WEBVIEW_TYPE*)webView webViewDelegate:(WVJB_WEBVIEW_DELEGATE_TYPE*)webViewDelegate handler:(WVJBHandler)handler resourceBundle:(NSBundle*)bundle
```
log方法
`+ (void)enableLogging;`

调用h5注册的方法，把消息从native传递给h5。这些方法内部全是调用的WebViewJavascriptBridgeBase类的`- (void)sendData:(id)data responseCallback:(WVJBResponseCallback)responseCallback handlerName:(NSString * )handlerName`方法.

```
- (void)send:(id)message;
- (void)send:(id)message responseCallback:(WVJBResponseCallback)responseCallback;
- (void)callHandler:(NSString*)handlerName;
- (void)callHandler:(NSString*)handlerName data:(id)data;
- (void)callHandler:(NSString*)handlerName data:(id)data responseCallback:(WVJBResponseCallback)responseCallback;
```

注册事件方法
`- (void)registerHandler:(NSString*)handlerName handler:(WVJBHandler)handler;`



### `WKWebViewJavascriptBridge`

h5与WKWeView交互的桥梁

方法定义同`WebViewJavascriptBridge`


### `WebViewJavascriptBridge.js.txt`

定义`WebViewJavascriptBridge`

属性

`sendMessageQueue`:将传递给native的消息，暂存在sendMessageQueue数组中
`receiveMessageQueue`:在调用bridge.init之前，receiveMessageQueue存在，并且将收到的来自native的消息存储在receiveMessageQueue中。在调用bridge.init时，遍历处理receiveMessageQueue中的消息
`messageHandlers`::存储注册在h5端的事件处理函数。以注册的事件名为key,以注册事件时定义的handler为value.（一般事件）

`messagingIframe`:通过改变messagingIframe.src来调用webview的`- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType`方法，将处理流程回到native端。


方法

`send`:调用native的注册的默认事件

`callHandler`:调用native注册的一般事件

`_fetchQueue`:将sendMessageQueue中的消息序列化为字符串

`_dispatchMessageFromObjC`:处理来自objc的消息

`_handleMessageFromObjC`:在调用bridge.init之前，receiveMessageQueue存在，并且将收到的来自oc的消息存储在receiveMessageQueue中

`registerHandler`:注册一般事件


## bridge的原理











## 参考




     
  
  
 
  
  