---
layout:     post
title:      Android消息推送方式
keywords:   Android, 消息推送, 服务器， 实时聊天, MIMA, Hibernate
category:   web 
description: 当我们开发需要和服务器交互的应用程序时，基本上都需要获取服务器端的数据，比如《地震及时通》就需要及时获取服务器上最新的地震信息。要获取服务器上不定时更新的信息一般来说有两种方法，第一种是客户端使用**Pull（拉）**的方式，隔一段时间就去服务器上获取信息，看是否有更新的信息出现。第二种就是服务器使用**Push（推送）**的方式，当服务器端有新信息了，则把最新的信息Push到客户端上。 
虽然Pull和Push两种方式都能实现获取服务器端更新信息的功能
tags:		[android, 消息推送]
---

当我们开发需要和服务器交互的应用程序时，基本上都需要获取服务器端的数据，比如《地震及时通》就需要及时获取服务器上最新的地震信息。要获取服务器上不定时更新的信息一般来说有两种方法，第一种是客户端使用**Pull（拉）**的方式，隔一段时间就去服务器上获取信息，看是否有更新的信息出现。第二种就是服务器使用**Push（推送）**的方式，当服务器端有新信息了，则把最新的信息Push到客户端上。 
虽然Pull和Push两种方式都能实现获取服务器端更新信息的功能，但是明显来说**Push is better than pull**。
**因为Pull方式更费客户端的网络流量，更主要的是费电量。**
 
在开发Android和iPhone应用程序时，我们往往需要从服务器不定的向手机客户端即时推送各种通知消息，iPhone上已经有了比较简单的和完美的推送通知解决方案，可是Android平台上实现起来却相对比较麻烦，最近利用几天的时间对Android的推送通知服务进行初步的研究。 
在Android手机平台上，Google提供了**C2DM（Cloud to Device Messaging）**服务，起初我就是准备采用这个服务来实现自己手机上的推送功能。 

**Android Cloud to Device Messaging (C2DM)**是一个用来帮助开发者从服务器向Android应用程序发送数据的服务。该服务提供了一个简单的、轻量级的机制，允许服务器可以通知移动应用程序直接与服务器进行通信，以便于从服务器获取应用程序更新和用户数据。C2DM服务负责处理诸如消息排队等事务并向运行于目标设备上的应用程序分发这些消息。 

下面是C2DM操作过程示例图:
![](/images/images/image001.png)

几种常见的方案： 

- 1）**轮询(Pull)**：应用程序应当阶段性的与服务器进行连接并查询是否有新的消息到达，你必须自己实现与服务器之间的通信，例如消息排队等。而且你还要考虑轮询的频率，如果太慢可能导致某些消息的延迟，如果太快，则会大量消耗网络带宽和电池。 


- 2）**SMS(Push)**：在Android平台上，你可以通过拦截SMS消息并且解析消息内容来了解服务器的意图。这是一个不错的想法，我就见过采用这个方案的应用程序。这个方案的好处是，可以实现完全的实时操作。但是问题是这个方案的成本相对比较高，你很难找到免费的短消息发送网关，关于这个方案的实现。 


- 3）**持久连接(Push)**：这个方案可以解决由轮询带来的性能问题，但是还是会消耗手机的电池。Apple的推送服务之所以工作的很好，是因为每一台手机仅仅保持一个与服务器之间的连接，事实上C2DM也是这么工作的。不过这个方案也存在不足，就是我们很难在手机上实现一个可靠的服务。Android操作系统允许在低内存情况下杀死系统服务，所以你的通知服务很可能被操作系统Kill掉了。 

前两个方案存在明显的不足，第三个方案也有不足，不过我们可以通过良好的设计来弥补，以便于让该方案可以有效的工作。毕竟，我们要知道GMail，GTalk以及GoogleVoice都可以实现实时更新的。 


**采用MQTT协议实现Android推送 **

MQTT是一个轻量级的消息发布/订阅协议，它是实现基于手机客户端的消息推送服务器的理想解决方案。
 
wmqtt.jar 是IBM提供的MQTT协议的实现。你可以从如下站点下载它。你可以将该jar包加入你自己的Android应用程序中。 

Really Small Message Broker (RSMB) ，他是一个简单的MQTT代理，同样由IBM提供。缺省打开1883端口，应用程序当中，它负责接收来自服务器的消息并将其转发给指定的移动设备。 

　架构如下图所示：
![](/images/images/111.gif)

**RSMB实现推送功能**

`Really Small Message Broker (RSMB)` ，他是一个简单的MQTT代理，同样由IBM提供，其查看地址是：http://www.alphaworks.ibm.com/tech/rsmb。缺省打开1883端口，应用程序当中，它负责接收来自服务器的消息并将其转发给指定的移动设备。
 
SAM是一个针对MQTT写的PHP库。我们可以从这个http://pecl.php.net/package/sam/download/0.2.0地址下载它.
send_mqtt.php是一个通过POST接收消息并且通过SAM将消息发送给RSMB的PHP脚本。 

 
**采用XMPP协议实现Android推送 **

这是我在项目中采用的方案。事实上Google官方的C2DM服务器底层也是采用XMPP协议进行的封装。 
**XMPP(可扩展通讯和表示协议)是基于可扩展标记语言（XML）的协议**，它用于即时消息（IM）以及在线探测。这个协议可能最终允许因特网用户向因特网上的其他任何人发送即时消息。 

androidpn是一个基于XMPP协议的java开源**Android push notification**实现。它包含了完整的客户端和服务器端。经过源代码研究我发现，该服务器端基本是在另外一个开源工程**openfire**基础上修改实现的，不过比较郁闷的是androidpn的文档是由韩语写的，所以整个研究过程基本都是读源码。 

androidpn实现如下图所示：
！[](/images/images/222.gif)

androidpn客户端需要用到一个基于java的**开源XMPP协议包asmack**，这个包同样也是基于openfire下的另外一个开源项目smack，不过我们不需要自己编译，可以直接把androidpn客户端里面的**asmack.jar**拿来使用。客户端利用asmack中提供的XMPPConnection类与服务器建立持久连接，并通过该连接进行用户注册和登录认证，同样也是通过这条连接，接收服务器发送的通知。 

androidpn服务器端也是java语言实现的，基于openfire开源工程，不过它的Web部分采用的是spring框架，这一点与openfire是不同的。
服务器架构如下：

Androidpn服务器包含两个部分，一个是**侦听在5222端口上的XMPP服务**，负责与客户端的XMPPConnection类进行通信，作用是用户注册和身份认证，并发送推送通知消息。另外一部分是Web服务器，采用一个轻量级的HTTP服务器，负责接收用户的Web请求。
服务器架构如下： 

！[](/images/images/333.gif)

最上层包含四个组成部分，分别是`SessionManager，Auth Manager，PresenceManager以及Notification Manager`。`SessionManager`负责管理客户端与服务器之间的会话，`Auth Manager`负责客户端用户认证管理，`Presence Manager`负责管理客户端用户的登录状态`NotificationManager`负责实现服务器向客户端推送消息功能。 

这个解决方案的最大优势就是简单，我们不需要象C2DM那样依赖操作系统版本，也不会担心某一天Google服务器不可用。利用XMPP协议我们还可以进一步的对协议进行扩展，实现更为完善的功能。 

采用这个方案，我们目前只能发送文字消息，不过对于推送来说一般足够了，因为我们不能指望通过推送得到所有的数据，一般情况下，利用推送只是告诉手机端服务器发生了某些改变，当客户端收到通知以后，应该主动到服务器获取最新的数据，这样才是推送服务的完整实现。 

## XMpp协议简介 ##

XMPP协议，它是一种基于XML的传递协议，具有很强的灵活性和可扩展性。它的特点是将复杂性从客户端转移到了服务器端。在网上可以找到很多的XMPP资料，这里就不在赘述了，不然越扯越多。总之，XMPP主要显著的优点主要有以下几个方面：

- 1、 **分布式**  任何人都可以运行自己的XMPP服务器，它没有主服务器
- 2、 **安全性很高**。使用SASL及TLS等技术的可靠安全性
- 3、 **开发性** 它是开源的，易于进行学习和了解
- 4、 **跨平台 ** 毋庸置疑，使用的XML进行传输的

说完优点，我们言归正传，基于XMPP协议的java开发有一个开源框架，那就是smack，它主要封装了一些XMPP的实现。而如果把它直接用在Android上是不行的，因为android缺少了一些java的类库，于是一个改进版的asmack诞生了，它是专门为android而改进的android smack。而另外一个开源框架的诞生，则是对在引用smack的基础上实现和服务器端的持久连接，以实现服务器对客户端的推送，那就是android push notification，简称androidpn。

Androidpn在客户端集成了asmack。这样就可以很容易的简立一个和服务器端的基于xmpp协议的socket连接。Androidpn的客户端中，进行管理连接的类是XmppManager，它主要用来管理连接的信息，比如XMPP的端口、IP、登录的用户名密码，以及对连接的维护。为什么还有用户名和密码？这不得不提到XMPP的具体细节。整个服务器端和客户端的通信是基于一个session（会话）过程，会话开始，首先会指定服务器的端口号，然后把上述提到的信息发送到服务器端，怎么发送消息的呢？以<stream>根节点的方式开始传递，只有在服务器和客户端关闭的时候才会发送它的结束标记</stream>。客户端通过XMPP协议只用做的就是接收消息，而所有其它的操作都交给服务器，比如管理连接、消息保存等等，这样就很大程度的减轻了客户端的负担。那么客户端和服务器端的消息回应是如何实现的？如要通过一个ID来标识，具体细节可以去查看XMPP协议。

一旦注册绑定后，服务器端就和客户端建立了连接，客户端只用负责去接收消息。所以当我们应用Androidpn的时候，客户端会非常的简单。而在服务器端，Androidpn又做了什么呢？

服务器端的展示方面，androidpn主要用到的技术是**Spring和Hibernate**。主要是用来展示用户状态和发送信息用的，这方面的技术已经比较成熟，就不再细说了，主要要说的还是XMPP的管理。在服务器端的源码中一个`org.androidpn.server.xmpp.net.Connection`类，主要是代表一个服务器上的XMPP连接，注意只是一个，它可以确保在服务器关闭的时候，发送一个</stream>标记到客户端，告知连接断开，需重新连接。

`org.androidpn.server.xmpp.session.SessionManager`主要用户管理所有会话，比如连接断开，删除session以及建立连接，添加session等等。

而**在管理Socket连接的时候，androidpn采用了MINA框架来进行管理，**MINA[https://mina.apache.org/](https://mina.apache.org/)的优点就是改变了我们传统的管理socket的方式，比如没建立一个socket开一个线程，而MINA可以实现多个线程管理N多个用户。在处理高并发的推送上无疑是有巨大的好处的。

合理的利用监听器来管理session，也是androidpn的优点。在安全性方面，制定了TLS(安全传输层)策略，并却采用了安全认证，这些方面都做的不错。

当然，不可避免的30秒钟的心跳包还是必不可少的。

总之，用Androidpn好处有以下方面：采用完全开放的XMPP协议进行数据传输（QQ，MSN，GTalk等都是采用的这种协议）；良好的框架支持（专门为android 而产生的推送框架asmack，以及很好的管理socket的框架MINA，都是很成熟的产品）；完全开放的源代码（我们可以在androidpn的基础上进行修改，来满足我们的任何需求变更）；大大的减少了客户端的代码，降低了android的开发难度。缺点不言而喻，使用了太多的框架，如果想要改一些具体的实现，可能会迁移发动全身。不过如果你个懒人的话，完全满足你的需求了。
