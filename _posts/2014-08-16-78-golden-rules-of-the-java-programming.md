---
layout: post
title: java编程的78条黄金法则
keywords: java
categories : [java, reprints]
tags : [java]
---

整理自网络，如果你知道原作者，请通知我。

------------------------

## 创建和销毁对象

1、考虑用静态工厂方法（返回类的实例的静态方法）代替构造器<br>
2、遇到多个构造器参数时要考虑用构造器<br>
3、用私有构造器或者枚举类型强化Singleton属性<br>
4、通过私有构造器强化不可实例化的能力<br>
5、避免创建不必要的对象<br>
6、消除过期的对象引用<br>
7、避免使用终结（final）方法<br>

## 对于所有对象都通用的方法

8、覆盖equals时请遵守通用约定<br>
9、覆盖equals时总要覆盖hashCode<br>
10、始终要覆盖toString<br>
11、谨慎地覆盖clone<br>
12、考虑实现Comparable接口<br>
 
## 类和接口

13、使类和成员的可访问性最小化<br>
14、在公有类中使用访问方法而非公有域<br>
15、使可变性最小化<br>
16、复合优于继承<br>
17、要么为继承为设计，并提供文档说明，要么就禁止继承<br>
18、接口优于抽象类<br>
19、接口只用于定义类型<br>
20、类层次优于标签类<br>
21、用函数对象表示策略<br>
22、优先考虑静态成员类<br>
 
## 泛型

23、不要在新代码中采用原生态类型<br>
24、消除非受检警告<br>
25、列表优先于数组<br>
26、优先考虑泛型<br>
27、优先考虑泛型方法<br>
28、采用有限制通配符来提升API的灵活性<br>
29、优先考虑类型安全的异构造器<br>
 
## 枚举和注解

30、用enum带起int常量<br>
31、用实例域代替序数<br>
32、用EnumSet代替位域<br>
33、用EnumMap代替序数索引<br>
34、用接口模拟可伸缩的枚举<br>
35、注解优先于命名模式<br>
36、坚持使用Override注解<br>
37、用标记接口定义类型<br>
 
## 方法

38、检查参数的有效性<br>
39、必要时进行保护性拷贝<br>
40、谨慎设计方法签名<br>
41、慎用重载<br>
42、慎用可变参数<br>
43、返回零长度的数组或者集合，而不是null<br>
44、为所有导出的API元素编写文档注释<br>
 
## 通用程序设计

45、将局部变量的作用域最小化<br>
46、for-each循环优先于传统的for循环<br>
47、了解和使用类库<br>
48、如果需要精确的答案，请避免使用float和double<br>
49、基本类型优先于装箱基本类型<br>
50、如果其他类型更适合，则尽量避免使用字符串<br>
51、当心字符串链接的性能<br>
52、通过接口引用对象<br>
53、接口优先于反射机制<br>
54、谨慎使用本地方法<br>
55、谨慎进行优化<br>
56、遵守普遍接受的命名惯例<br>
 
## 异常

57、只针对异常的情况才使用异常<br>
58、对可恢复的情况使用受检异常，对编程错误使用运行时异常<br>
59、避免不必要地使用受检的异常<br>
60、优先使用标准的异常<br>
61、抛出与抽象相对应的异常<br>
62、每个方法抛出的异常都要有文档<br>
63、在细节消息中包含捕获失败的信息<br>
64、努力使失败包含原子性<br>
65、不要忽略异常<br>
 
## 并发

66、同步访问共享的可变数据<br>
67、避免过度同步<br>
68、executor和task优先于线程<br>
69、并发工具优先于wait和notify<br>
70、线程安全性的文档化<br>
71、慎用延迟初始化<br>
72、不要依赖于线程调度器<br>
73、避免使用线程组<br>
 
## 序列化

74、谨慎的实现Seriallizable接口<br>
75、考虑使用自定义的序列化形式<br>
76、保护性的编写readObject方法<br>
77、对于实例控制，枚举类型优先于readResolve<br>
78、考虑用序列化代理代替序列化实例<br>

